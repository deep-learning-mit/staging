<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Optimizations of Transformers for Small-scale Performance | 6.S898 Deep Learning Blogs 2023</title> <meta name="author" content="abc b c"/> <meta name="description" content="CNNs generally outperform ViTs in scenarios with limited training data. However, the narrative switches when the available training data is extensive. To bridge this gap and improve upon existing ViT methods, we explore how we can leverage recent progress in the transformer block and exploit the known structure of pre-trained ViTs."/> <meta name="keywords" content="machine-learning, ml, deep-learning, reinforcement-learning, iclr"/> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"/> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"/> <link rel="stylesheet" href="/staging/assets/css/main.css"> <link rel="canonical" href="https://deep-learning-mit.github.io/staging/blog/2023/diaz-proposal/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"/> <script src="/staging/assets/js/theme.js"></script> <script src="/staging/assets/js/dark_mode.js"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/staging/assets/js/distillpub/template.v2.js"></script> <script src="/staging/assets/js/distillpub/transforms.v2.js"></script> <script src="/staging/assets/js/distillpub/overrides.js"></script> <style type="text/css">.fake-img{background:#bbb;border:1px solid rgba(0,0,0,0.1);box-shadow:0 0 4px rgba(0,0,0,0.1);margin-bottom:12px}.fake-img p{font-family:monospace;color:white;text-align:left;margin:12px 0;text-align:center;font-size:16px}</style> </head> <d-front-matter> <script async type="text/json">{
      "title": "Optimizations of Transformers for Small-scale Performance",
      "description": "CNNs generally outperform ViTs in scenarios with limited training data. However, the narrative switches when the available training data is extensive. To bridge this gap and improve upon existing ViT methods, we explore how we can leverage recent progress in the transformer block and exploit the known structure of pre-trained ViTs.",
      "published": "December 10, 2023",
      "authors": [
        {
          "author": "Sebastian (Sebo) Diaz",
          "authorURL": "",
          "affiliations": [
            {
              "name": "MIT",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> <body class="fixed-top-nav"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/staging/">6.S898 Deep Learning Blogs 2023</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/staging/blog/index.html">blog</a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">past iterations</a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item" href="https://iclr-blog-track.github.io/home/">2022</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> </header> <div class="post distill"> <d-title> <h1>Optimizations of Transformers for Small-scale Performance</h1> <p>CNNs generally outperform ViTs in scenarios with limited training data. However, the narrative switches when the available training data is extensive. To bridge this gap and improve upon existing ViT methods, we explore how we can leverage recent progress in the transformer block and exploit the known structure of pre-trained ViTs.</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div><a href="#transformers-great-but-not-enough">Transformers: Great But Not Enough</a></div> <ul> <li><a href="#basic-background">Basic Background</a></li> <li><a href="#vision-the-problem">Vision: The Problem</a></li> <li><a href="#transformer-block">Transformer Block</a></li> </ul><div><a href="#translation-to-vision-experimentation-and-analysis">Translation to Vision: Experimentation and Analysis</a></div> <ul> <li><a href="#vanilla-vs-simplified-comparison">Vanilla vs. Simplified Comparison</a></li> <li><a href="#initialization-schemes">Initialization Schemes</a></li> </ul><div><a href="#conclusion-and-limitations">Conclusion and Limitations</a></div> </nav> </d-contents> <div class="text-center"> <a name="figure-1"></a> <img src="https://discuss.tensorflow.org/uploads/default/original/2X/4/44b54935a57a92b71902d81265e9bc3c6d99fb12.gif" width="700" height="250"/> <p class="caption"> Figure 1: Attention Maps of a Vision Transformer (DINO). Source: <a href="https://github.com/sayakpaul/probing-vits">https://github.com/sayakpaul/probing-vits </a>. </p> </div> <h2 id="transformers-great-but-fall-short">Transformers: Great but fall short</h2> <h3 id="basic-background">Basic Background</h3> <p>Transformers have well-earned their place in deep learning. Since the architecture’s introduction in<d-cite key="AttentionIsAllYouNeed"></d-cite>, we have seen huge improvements in our model’s capabilities. The most notable of which being natural language processing (NLP) with large-language models such as GPT-4 stunning the world at-large.</p> <p>Originally designed for NLP, the transformer architecture has been robust in other domains and tasks. For example, it has been translated, with success, to de-novo protein design<d-cite key="Grechishnikova2021"></d-cite>, the medical field<d-cite key="Hu2022"></d-cite>, and, of most relevance, computer vision<d-cite key="Dosovitskiy2020"></d-cite>. This behaviour differs from architectures of the past like RNNs and CNNs which have been limited to one domain. The potent generalizability of the transformer lies within the self-attention mechanism. Without getting to much into detail, self-attention enables nodes within a neural network to probe the input sequence, determine what is most interesting, and attend towards the region of interest by dynamically updating its weights. Visualization of attention can be seen in <a href="#figure-1">Figure 1</a>. By probing the data landscape, the architecture enables long-range dependencies to be modeled regardless of distance. From a Fourier perspective, the transformer caters towards the low-frequency information in the data and deciphers how each element of an input sequence all relate to each other<d-cite key="Wang2022"></d-cite>. These connections help the transformer accurately model global information in the data perhaps indicating why they are so powerful. In this blog, we will specifically examine the transformer in vision, determine how it can be improved, and evaluate new strategies to increase its viability on small datasets.</p> <div class="col-sm text-center"> <a name="figure-2"></a> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/staging/assets/img/2023-11-08-diaz-proposal/vit_workflow-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/staging/assets/img/2023-11-08-diaz-proposal/vit_workflow-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/staging/assets/img/2023-11-08-diaz-proposal/vit_workflow-1400.webp"/> <img src="/staging/assets/img/2023-11-08-diaz-proposal/vit_workflow.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="caption"> Figure 2: ViT workflow. </div> </div> <h3 id="vision-the-problem">Vision: The Problem</h3> <p>The Vision Transformer (ViT)<d-cite key="Dosovitskiy2020"></d-cite> introduced the transformer to the computer vision world in late 2020. The ViT is simple: it funnels image patches into a tokenization scheme, adds positional encoding, and feeds these tokens into a transformer block. A graphical workflow of the ViT from the original paper can be seen in <a href="#figure-2">Figure 2</a>.</p> <p>Since its introduction, the ViT and associated variants have demonstrated remarkable benchmarks in image classification<d-cite key="Liu2021"></d-cite>, image restoration<d-cite key="Liang2021"></d-cite>, and object detection<d-cite key="Li2022"></d-cite>. Much of these new methods can compete and even outperform long-established CNNs. However, ViTs are data-hungry requiring extensive amounts of training data to surpass CNNs. In small scale training, ViTs are burdensome to train and achieve sub-par performance compared to their CNNs counterparts<d-cite key="Naimi2021"></d-cite>. In <d-cite key="Zhu2023"></d-cite>, they investigate this discrepancy by comparing the feature and attention maps of small-scale CNNs and ViTs, respectively. The authors determine the ViT lacks the ability to learn local information and has ill-suited representation capacity in the lower layers. In contrast, the CNN demonstrate remarkable inductive bias due to weight sharing and locality properties which enable high-frequency modeling<d-cite key="Park2022"></d-cite>. The ViT’s low-frequency and the CNNs high-frequency capacity has initiated a wave of new models aimed at combining the two for comprehensive modeling capability<d-cite key="Si2022"></d-cite><d-cite key="ConvViT"></d-cite>.</p> <p>Despite the complementary nature of these architectures, they break the fidelity of the transformer and make for difficult analysis. Therefore, there exists a gap in the traditional transformer architecture to perform in small-data regimes, particularly in vision. Motivated by this shortcoming, we aim to investigate and improve the current ViT paradigm to narrow the gap between CNNs and ViTs on small-data. In particular, we examine novel initialization schemes, removal of component parts in our transformer block, and new-learnable parameters which can lead to better performance, image throughput, and stable training on small-scale datasets.</p> <div class="col-sm text-center"> <a name="figure-3"></a> <img src="/staging/assets/img/2023-11-08-diaz-proposal/transformer.svg" class="img-fluid rounded z-depth-1" style="width: 300px;"/> <div class="caption"> Figure 3: Standard transformer encoder block. Encoder can be stacked for x amount of layers. </div> </div> <h3 id="transformer-block">Transformer Block</h3> <p>To serve as a basis of comparison, we will examine the stanford transformer block seen in <a href="#figure-3">Figure 3</a>. The block is identical to <d-cite key="AttentionIsAllYouNeed"></d-cite> with the exception of using layer normalizations before the multi-headed attention (MHA) and multi-level perceptron (MLP) blocks as opposed to after. In practice, this placement has been shown to be more stable and increase performance<d-cite key="Liu2020"></d-cite>. With the exception of this modification, the block has seen little improvements over the years testifying to its robustness. However, recent trends in theory hints towards ways we could break this notion – all while enjoying increased performance.</p> <p>Before we delve into these advances and their implications, consider the following transformer block information flow:</p> \[\displaylines{ \text{Attention} = \text{A}(X) = \text{Softmax}\Biggl(\frac{XW_{Q}W_{K}^{T}X^{T}}{\sqrt{k}}\Biggl) \\ \\ \text{A}(X) \in \mathbb{R}^{T\times T}}\] <p>which is shortly followed by:</p> \[\displaylines{ \text{S}(X) = \text{A}(X)W_{V}W_{O} \\ \\ \text{S}(X) \in \mathbb{R}^{T\times d} }\] <p>and:</p> \[\text{Output} = \text{MLP}(\text{S}(X))= \text{Linear}(\text{GELU}(\text{Linear}(\text{S}(X))))\] <p>where:</p> <ul> <li>Embedded input sequence: \(X \in \mathbb{R}^{T \times d}\)</li> <li>Linear queury and key layers: \(W_{Q},W_{K} \in \mathbb{R}^{d \times k}\)</li> <li>Linear value and projection layers: \(W_{V}, W_{O} \in \mathbb{R}^{d \times d}\)</li> <li>MLP Linear layers: \(\text{Linear} \in \mathbb{R}^{d \times d}\)</li> <li>\(T =\) # of tokens, \(d =\) embedding dimension, \(k = \frac{d}{H}\), \(H =\) # of attention heads</li> </ul> <p>The flow of information mirrors the transformer block in <a href="#figure-3">Figure 3</a>. Readers unfamiliar with transformer intricacies such as MHA and MLPs are encouraged to read<d-cite key="AttentionIsAllYouNeed"></d-cite>.</p> <p>Recently, there have been many proposals on how the transformer block can be further modified to increase data throughput and eliminate “redundant” or “useless” parts that do not have any significant contribute to the tranformer’s modeling capabilities. For example, <d-cite key="2302.05442"></d-cite>, used a parallel MHA and MLP incorporated into a large-scale ViT for stable and efficient training. Throughout this blog, we will focus on the ideas overviewed and proposed by <d-cite key="He2023"></d-cite> as they present intriguing results and a synthesis on the current state of this research topic. The interested reader is encouraged to study their paper for a more extensive understanding of the ideas.</p> <div class="col-sm text-center"> <a name="figure-4"></a> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/staging/assets/img/2023-11-08-diaz-proposal/simplified_block-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/staging/assets/img/2023-11-08-diaz-proposal/simplified_block-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/staging/assets/img/2023-11-08-diaz-proposal/simplified_block-1400.webp"/> <img src="/staging/assets/img/2023-11-08-diaz-proposal/simplified_block.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="caption"> Figure 4: Comparison between trasnformer architectures. <em>Left</em>: Standard block as shown in Figure 3. <em>Bottom Right</em>: Parallel block proposed in. <em>Top Right</em>: Newly proposed encoder. </div> </div> <p>The overaching theme of <d-cite key="He2023"></d-cite> was to take the standard trasnformer block and evaluate the necessity of each component. In doing so, they removed each component part and studied its effects on performance. Understandably, blindly removing components will lead to unstable training and ill-performance (i.e. if one were to remove the skip connnections, they would encounter vanishing gradients as seen <a href="#figure-14">Figure 14</a>). However, <d-cite key="He2023"></d-cite> took the approach of removal combined with recovery. For example, when the authors removed skip connections, they required a modification to the self-attention matrix of the form:</p> \[\text{A}(X) \leftarrow (\alpha\text{I} + \beta \text{A}(X))\] <p>where \(\alpha\) and \(\beta\) are learnable scalars and intialized to \(1\) and \(0\), respectively, and \(\text{I} \in \mathbb{R}^{T \times T}\) is the identity matrix. This modification intiailizes the self-attention matrix providing a pathway towards training stability. They further entertained a more complicated scheme with a third parameter, but we only consider the two parameter version for simplicity. By this iterative removal and recovery process, the authors converged towards the final transformer block seen in <a href="#figure-4">Figure 4</a>. The most shocking aspect of this proposed block is the removal of the \(W_{V}\) and \(W_O\) layers. They arrived to this justification by initialializing \(W_{V}\) and \(W_{O}\) to the identity with separate, learnable scalars and training a model. Over the course of training, the scalar ratios converged towards zero<d-footnote>This is a slight simplification. Look at Section 4.2 and Figures 4 and 20 in He et. al 2023 for a more detailed explanation.</d-footnote>. Due to the heavy cost and speed these linear layers present, removal of them decreases parameters counts and enables more data throughput. A concise PyTorch interpretation of the new block can be seen below:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">torch</span>
<span class="kn">import</span> <span class="n">torch.nn</span> <span class="k">as</span> <span class="n">nn</span>

<span class="k">class</span> <span class="nc">ShapedAttention</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n_hidden</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">num_heads</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">().</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="c1"># Determining if hidden dimension of attention layer is divisible by number of heads
</span>        <span class="k">assert</span> <span class="n">width</span> <span class="o">%</span> <span class="n">num_heads</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="sh">"</span><span class="s">Width and number of heads are not divisble.</span><span class="sh">"</span>
        
        <span class="c1"># Setting vars
</span>        <span class="n">self</span><span class="p">.</span><span class="n">head_dim</span>   <span class="o">=</span> <span class="n">n_hidden</span> <span class="o">//</span> <span class="n">num_heads</span>
        <span class="n">self</span><span class="p">.</span><span class="n">num_heads</span>  <span class="o">=</span> <span class="n">num_heads</span>
        <span class="c1"># Creating Linear Layers
</span>        <span class="n">self</span><span class="p">.</span><span class="n">W_K</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">head_dim</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">W_Q</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">head_dim</span><span class="p">)</span>
        <span class="c1"># Learnable Scalars: alpha_init and beta_init are up to user
</span>        <span class="n">self</span><span class="p">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Parameter</span><span class="p">(</span><span class="n">alpha_init</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">beta</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Parameter</span><span class="p">(</span><span class="n">beta_init</span><span class="p">)</span>
        <span class="c1"># Softmax
</span>        <span class="n">self</span><span class="p">.</span><span class="n">softmax</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Softmax</span><span class="p">(</span><span class="n">dim</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="p">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="p">.</span><span class="n">Tensor</span><span class="p">:</span>
        <span class="c1"># Input:
</span>        <span class="c1"># x: shape (B x T x dim)
</span>        <span class="c1"># Outputs:
</span>        <span class="c1"># attn_output: shape (B x T x width)
</span>        <span class="n">attn_output</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="c1"># Compute keys and queries
</span>        <span class="n">k</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nc">W_K</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nc">W_Q</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># Scaled dot-product
</span>        <span class="n">attn_scores</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">bmm</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">k</span><span class="p">.</span><span class="nf">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">head_dim</span><span class="o">**-</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">attn_scores</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">softmax</span><span class="p">(</span><span class="n">attn_scores</span><span class="p">)</span>
        <span class="c1"># Shaped attention
</span>        <span class="n">B</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">shape</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">alpha</span><span class="o">*</span><span class="n">torch</span><span class="p">.</span><span class="nf">eye</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">device</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">device</span><span class="p">)</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">beta</span> <span class="o">*</span> <span class="n">attn_scores</span>

        <span class="k">return</span> <span class="n">output</span>
</code></pre></div></div> <p>The performance of the final transformer block (referred to as SAS-P) demonstrated powerful results. In the <a href="#figure-5">Figure</a>, the simplified transformer matches the standard block in cross-entropy loss even when taken through a long runtime. Additionally, Figure 6 in <d-cite key="He2023"></d-cite> demonstrates the model scales better with depth which is of paramount importance in modern neural network.</p> <div class="col-sm text-center"> <a name="figure-5"></a> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/staging/assets/img/2023-11-08-diaz-proposal/fig5-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/staging/assets/img/2023-11-08-diaz-proposal/fig5-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/staging/assets/img/2023-11-08-diaz-proposal/fig5-1400.webp"/> <img src="/staging/assets/img/2023-11-08-diaz-proposal/fig5.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="caption"> Figure 5: Training speed experiment. Figure 6. in Ref. 15. Pre-LN is the standard transformer block. SAS-P is the block. It is shown with and without an initial layer normalization. </div> </div> <h2 id="translation-to-vision-experimentation-and-analysis">Translation to Vision: Experimentation and Analysis</h2> <p>The results shown in <d-cite key="He2023"></d-cite> show promise the transformer can be improved. Motivated by vision applications, we seek to implement such infrastructure, with slight modifications, and determine if it improves performance in small datasets.</p> <h3 id="vanilla-vs-simplified-comparison">Vanilla vs. Simplified Comparison</h3> <p>For evaluation, we compare the simplified transformer to a vanilla ViT. The vanilla ViT’s transformer block is identical to the formulation presented earlier. We use Conv2D patch embedding with a random initial positional embedding. For the simplified setup, we initialize \(\alpha = \beta = 0.5\) and do not use a centering matrix – although it has been shown to improve ViT performance<d-cite key="2306.01610"></d-cite>. We use one Layer Normalization just prior to the transformer encoder. \(\text{Width} = 96\) is kept uniform throughout the model. The dataset is CIFAR-10 with a \(\text{batch size} = 256\). Data augmentations were random horizontal and vertical flips with 15º random rotations. Optimizer is AdamW with \(\text{lr} = 0.003\) and \(\text{weight decay} = 0.01\). We employ a cosine learning rate scheduler to maintain consistency with ViT literature, although <d-cite key="He2023"></d-cite> empirically showed a linear learning rate is slightly advantegeous<d-footnote>Figure 11 in He et. al 2023.</d-footnote>. We ran our model for \(\text{epochs} = 50\) with \(\text{runs} = 3\) to evalute run-to-run stability. A condensed version of the experiment choices can be seen in Table 1. The results can be seen in <a href="#figure-6">Figure 6</a> and Table 2<d-footnote>To avoid clutter, only the training accuracies vs epochs are shown. Loss curves showed similar relationships.</d-footnote>.</p> <table> <thead> <tr> <th>Table 1. Experiment 1: ViT Model Settings</th> <th> </th> </tr> </thead> <tbody> <tr> <td># of channels</td> <td>3</td> </tr> <tr> <td>Image size</td> <td>32</td> </tr> <tr> <td>Patch size</td> <td>4</td> </tr> <tr> <td>Width</td> <td>96</td> </tr> <tr> <td># of heads</td> <td>4</td> </tr> <tr> <td># of layers</td> <td>8</td> </tr> </tbody> </table> <div class="l-page" style="display: flex; flex-direction: column; align-items: center; margin-bottom: 0px;"> <a name="figure-6"></a> <iframe src="/staging/assets/html/2023-11-08-diaz-proposal/exp1_w96.html" frameborder="0" scrolling="no" height="500px" width="70%"></iframe> <div class="caption" style="margin-top: 10px; text-align: center;"> Figure 6. Comparison between vanilla and simplified transformers. Width = 96. Layers/Depth = 8. </div> </div> <table> <thead> <tr> <th>Table 2. Experiment 2: Results</th> <th style="text-align: center">Vanilla</th> <th style="text-align: right">Simplified</th> <th style="text-align: right">\(\Delta\)</th> </tr> </thead> <tbody> <tr> <td>Parameters</td> <td style="text-align: center">358186</td> <td style="text-align: right">209210</td> <td style="text-align: right">-41.59%</td> </tr> <tr> <td>Avg. epoch time (s)</td> <td style="text-align: center">12.954</td> <td style="text-align: right">11.305</td> <td style="text-align: right">-12.73%</td> </tr> </tbody> </table> <p>Experiment 1 showed the training evaluation trajectory is nearly identicable between the two models although the simplified outperforms by small margin. Although the subtle difference, it is noteworthy to mention the simplified version achieved mirroring performance with less parameters and higher image throughput. The similarity of the curves hints the removal of the skip connections, layer normalizations, and value/projection layers were merited, begging the question whether these components held our modeling power back.</p> <p>This experimentation shows the similar nature of each model, but does not translate well to wider modern neural networks. In Experiment 2, we expanded to \(\text{width} = 128\) to determine if there is any emergent behaviour as the network becomes wider. We replicate everything in Experiment 1 and solely modify the width. The settings are restated in Table 3. The results for Experiment 2 can be seen in <a href="#figure-7">Figure 7</a> and Table 4 below.</p> <table> <thead> <tr> <th>Table 3</th> <th>Experiment 2: ViT Model Settings</th> </tr> </thead> <tbody> <tr> <td># of channels</td> <td>3</td> </tr> <tr> <td>Image size</td> <td>32</td> </tr> <tr> <td>Patch size</td> <td>4</td> </tr> <tr> <td>Width</td> <td>128</td> </tr> <tr> <td># of heads</td> <td>4</td> </tr> <tr> <td># of layers</td> <td>8</td> </tr> </tbody> </table> <div class="l-page" style="display: flex; flex-direction: column; align-items: center; margin-bottom: 0px;"> <a name="figure-7"></a> <iframe src="/staging/assets/html/2023-11-08-diaz-proposal/exp2_w128.html" frameborder="0" scrolling="no" height="500px" width="70%"></iframe> <div class="caption" style="margin-top: 10px; text-align: center;"> Figure 7. Comparison between vanilla and simplified transformers. Width = 128. Layers/Depth = 8. </div> </div> <table> <thead> <tr> <th>Table 4. Experiment 2: Results</th> <th style="text-align: center">Vanilla</th> <th style="text-align: right">Simplified</th> <th style="text-align: right">\(\Delta\)</th> </tr> </thead> <tbody> <tr> <td>Parameters</td> <td style="text-align: center">629130</td> <td style="text-align: right">364954</td> <td style="text-align: right">-41.99%</td> </tr> <tr> <td>Avg. epoch time (s)</td> <td style="text-align: center">13.093</td> <td style="text-align: right">11.735</td> <td style="text-align: right">-10.37%</td> </tr> </tbody> </table> <p>The narrative is different for Experiment 2. The simplified version outperforms the vanilla version by a considerable margin. An adequate explanation for this discrepancy in vision tasks merits further exploration. However, considering the proposed unnecessary nature of the value and projection matrices, we can hypothesize they interfere with the modeling capability as more parameters are introduced.</p> <p>Due to the sheer difference in outcomes between the models, we question how the models are attending towards various inputs to gain a better understanding of what is happening under the hood. To probe this curiosity, we trained the models with identical setting in Experiment 2, but modified the \(\text{depth} = \text{layers} = 12\). This model setup will be covered in more detail in future paragraphs. We inputted CIFAR-10 to each model and visualized a side-by-side comparison of attention maps for five input images. An interactive figure is seen <a href="#figure-8">Figure 8</a>.</p> <div class="l-page" style="display: flex; flex-direction: column; align-items: center; margin-bottom: 0px;"> <div style="display: flex; flex-direction: column; align-items: center;"> <a name="figure-8"></a> <iframe src="/staging/assets/html/2023-11-08-diaz-proposal/attention_maps.html" frameborder="0" scrolling="no" height="600px" width="70%"></iframe> <div class="caption" style="margin-top: 10px; text-align: center;"> Figure 8. Comparison between vanilla and simplified attention maps. Width = 128. Layers/Depth = 12. Interpolation method: "nearest". </div> </div> </div> <p>There is a noticeable contrast in the attention maps. For the simplified model, the attention maps seem to place weight in a deliberation manner, localizing the attention towards prominent features in the input image. On the other hand, the vanilla model is choatic in its attention allocation. It is noteworthy that the vanilla model does place attention towards areas of interest, but also attends towards irrelevant information perhaps compromising its judgement at the time of classification. It can thus be reasoned the simplified model can better decipher which features are relevant demonstrating, even in low data regimes, the representational quality is increased.</p> <p>While we have so far investigated width, it will be informative to understand how depth impacts the performance of the simplified version. In <d-cite key="He2023"></d-cite>, they employ signal propagation theory, which is most prominent in deeper networks. Therefore, we suspect as we increase the depth of our models, the simplified version will outperform the vanilla version by a larger margin. Here, we set \(\text{layers} = 12\) and maintain \(\text{width}=128\). The training accuracies and experiment results are seen in <a href="#figure-9">Figure 9</a> and Table 5.</p> <div class="l-page" style="display: flex; flex-direction: column; align-items: center; margin-bottom: 0px;"> <a name="figure-9"></a> <iframe src="/staging/assets/html/2023-11-08-diaz-proposal/exp3_w128_l12.html" frameborder="0" scrolling="no" height="500px" width="70%"></iframe> <div class="caption" style="margin-top: 10px; text-align: center;"> Figure 9. Comparison between vanilla and simplified transformers. Width = 128. Layers/Depth = 12. </div> </div> <table> <thead> <tr> <th>Table 5. Experiment 3: Results</th> <th style="text-align: center">Vanilla</th> <th style="text-align: right">Simplified</th> <th style="text-align: right">\(\Delta\)</th> </tr> </thead> <tbody> <tr> <td>Parameters</td> <td style="text-align: center">927370</td> <td style="text-align: right">531106</td> <td style="text-align: right">-42.72%</td> </tr> <tr> <td>Avg. epoch time (s)</td> <td style="text-align: center">17.527</td> <td style="text-align: right">15.723</td> <td style="text-align: right">-10.29%</td> </tr> </tbody> </table> <p>Again, the simplified model outperforms the vanilla model by a large margin. Although we have focused on performance in the past, we discern an interesting trend when we scaled the depth: the simplified version seemed to be more consistent from run-to-run (recall \(\text{runs} = 5\)). This leads us to believe that as we continue to scale the depth, the simplified version will be more stable. Future experimentation will be necessary to corroborate this claim.</p> <h3 id="initialization-schemes">Initialization Schemes</h3> <p>We have seen the impact simplification can have on the performance of the transformer performance and self-attention. However, the used initializatons of \(\alpha\) and \(\beta\) in Experiments 1, 2, and 3, was based on equal weighting between the initial attention matrix and the identity matrix. In <d-cite key="He2023"></d-cite>, they employ a full weighting of the identity matrix and zero’d out the attention matrix at initialization. Here, we aim to determine the effect of different initialization values. Recall \(\alpha = \beta = 0.5\) in Experiments 1, 2, 3. Now, we investigate two more initializaton schemes: \(\alpha = 1.0\) and \(\beta = 0.0\) and vice-versa. We replicate the protocol used in Experiment 2 and only modify these learnable scalar at initializaton and set \(\text{runs} = 1\). The results are shown in <a href="#figure-10">Figure 10</a>. Interestingly, the initialization scheme proposed by <d-cite key="He2023"></d-cite>, does <em>not</em> outperform the equal weighting or inverse weighting scheme. Understandably, it does poorly at initialization, but never recovers. The equal weighting and inverse weighting approaches show nearly identical performance often trading off superior performance from epoch-to-epoch.</p> <div class="l-page" style="display: flex; flex-direction: column; align-items: center; margin-bottom: 0px;"> <a name="figure-10"></a> <iframe src="/staging/assets/html/2023-11-08-diaz-proposal/exp4_init_new.html" frameborder="0" scrolling="no" height="500px" width="80%"></iframe> <div class="caption" style="margin-top: 10px; text-align: center;"> Figure 10. Various Initialization Schemes. </div> </div> <p>This lead us to believe the initializaton scheme could be improved. There has been some work on initializing vanilla ViTs<d-cite key="Trockman2023"></d-cite> to gain performance. In <d-cite key="Trockman2023"></d-cite>, a prominent diagonal was observed for the \(W_{q}W_{k}^{T}\) layers in ViT’s pre-trained on large datasets, which have been shown to outperform CNNs. The figure shown in the paper can be seen in <a href="#figure-10">Figure 10</a>. This motivated the authors to provide a novel initialization scheme where the \(W_{Q}\) and \(W_{K}\) matrices are initialized in a way to encourage diagonal prominence in the forward pass. However, our findings contradicted this scheme, as our diagonal-dominant initialization scheme \(\alpha = 1\) and \(\beta = 0\) did not out perform the inverse or the equal weighting. This is likely due to the fact we have learnable parameters and do not initialize our \(W_{Q}\) and \(W_{K}\)’s directly, but rather the attention matrix post-softmax. However, it is important to realize that the learnable parameters still encourage diagonal prominence regardless of intialization. Although<d-cite key="Trockman2023"></d-cite> used this initialization scheme to increase performance in small ViT’s trained from scratch, which encourages tokens to attend toward to themselves through the depth of the network, they did not take into consideration how the diagnolization varys from layer-to-layer. Seen in <a href="#figure-10">Figure 10</a>, we can see the prominence of the diagnoal elements fades as we go deeper into the network. Observing this behaviour, we hypothesize the reason the initialization scheme of \(\alpha = 1\) and \(\beta = 0\) underperformed was not due to the initialization itself, but how it was applied to each layer. In other words, when we initialized \(\alpha = 1\) and \(\beta = 0\), we encouraged this token self-attentive nature throughout the depth of the network, when we should be encouraging it in the opening layers and tapering it off as we approach the end of the model.</p> <p>To give more evidence to this hypothesis, we experimented with the following dynamic initialization scheme:</p> \[\displaylines{ \alpha_i = \frac{1}{i}, \beta_i = 1 - \frac{1}{i} \\ \text{ where } i \in [1, 2, ..., L] \text{ and } L = \text{# of layers} }\] <p>The results from this initialization scheme compared to the uniform initializations can be seen in <a href="#figure-12">Figure 12</a> The results show that the dynamic scheme outperform the results perhaps indicating the representation quality is connected toward encouraging self-token connection in the lower layers, while allowing for token’s to intermingle in higher layers. We further experiment with the inverse dynamic where we switch the \(\alpha\) and \(\beta\) values. The results in <a href="#figure-13">Figure 13</a> show the dynamic approach is stronger during training then the inverse dynamic approach.</p> <div class="col-sm text-center"> <a name="figure-11"></a> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/staging/assets/img/2023-11-08-diaz-proposal/diagonal_vit_tiny-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/staging/assets/img/2023-11-08-diaz-proposal/diagonal_vit_tiny-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/staging/assets/img/2023-11-08-diaz-proposal/diagonal_vit_tiny-1400.webp"/> <img src="/staging/assets/img/2023-11-08-diaz-proposal/diagonal_vit_tiny.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="caption"> Figure 11: Diagonal prominence in a pre-trained ViT Tiny. Layers 1-11 (Left-to-Right). Heads 1-3 (Top-to-Bottom). Extracted from Figure 1 of <a href="https://arxiv.org/abs/2305.09828">Mimetic Initialization of Self-Attention Layers</a>. </div> </div> <div class="l-page" style="display: flex; flex-direction: column; align-items: center; margin-bottom: 0px;"> <a name="figure-12"></a> <iframe src="/staging/assets/html/2023-11-08-diaz-proposal/exp5_init_dynamic.html" frameborder="0" scrolling="no" height="500px" width="80%%"></iframe> <div class="caption" style="margin-top: 10px; text-align: center;"> Figure 12. Experiment 5: Dynamic vs. Uniform Initializations. </div> </div> <div class="l-page" style="display: flex; flex-direction: column; align-items: center; margin-bottom: 10px;"> <a name="figure-13"></a> <iframe src="/staging/assets/html/2023-11-08-diaz-proposal/exp6_init_inverse.html" frameborder="0" scrolling="no" height="500px" width="80%"></iframe> <div class="caption" style="margin-top: 10px; text-align: center;"> Figure 13. Experiment 6: Dynamic vs. Inverse Dynamic Initializations. </div> </div> <h2 id="conclusion-and-limitations">Conclusion and Limitations</h2> <p>Through this blog post we have overviewed the simplification of our known transformer block and novel initialization schemes. We took the problem of small-scale training of ViT’s and looked to address it leveraging such ideas. Through a series of experiments and thoughtful schemes, we generated an informed and sophisticated approach to tackle such a problem. In the end, we generated a method that outperformed a tradtional ViT in small scales. We explored ways of scaling the ViT in width and depth and probed how the new model distributed attention. Our comparisons were intentionally simple and effective in addressing the underlying task and illustrating the models potential. Although the results presented showed promise, extensive validation needs to be performed in the future. It will be interesting to see how this new transformer block and intialization scheme can be further utilized in computer vision. For example, a logical next route to entertain is to compare convergence rates in larger scale ViT on datasets such as ImageNet-21k to see if the modeling advantage persists.</p> <p>There are a few limitations in this study. For one, only one dataset was used. Using other datasets such as CIFAR-100 or SVHN would provide more insight into this methodology. Secondly, there is a need for more comprehensive evaluation and ablation studies to determine the true nature of the simplified transformer and initialization schemes. Third, a comparison to a smaller scale CNNs is needed to gauge where this method comparatively sits in modeling power.</p> <div class="l-page" style="display: flex; flex-direction: column; align-items: center; margin-bottom: 10px;"> <a name="figure-14"></a> <iframe src="/staging/assets/html/2023-11-08-diaz-proposal/exp0.html" frameborder="0" scrolling="no" height="500px" width="80%"></iframe> <div class="caption" style="margin-top: 10px; text-align: center;"> Figure 14. Experiment 0: Removal of skip connections in traditional ViT. </div> </div> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> </div> <d-bibliography src="/staging/assets/bibliography/2023-11-08-diaz-proposal.bib"></d-bibliography> <script src="https://utteranc.es/client.js" repo="iclr-blogposts/2023" issue-term="pathname" theme="github-light" crossorigin="anonymous" async> </script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> </body> </html>