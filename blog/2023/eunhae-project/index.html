<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>How does model size impact catastrophic forgetting in online continual learning? | 6.S898 Deep Learning Blogs 2023</title> <meta name="author" content="abc b c"/> <meta name="description" content="Yes, model size matters."/> <meta name="keywords" content="machine-learning, ml, deep-learning, reinforcement-learning, iclr"/> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"/> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"/> <link rel="stylesheet" href="/staging/assets/css/main.css"> <link rel="canonical" href="https://deep-learning-mit.github.io/staging/blog/2023/eunhae-project/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"/> <script src="/staging/assets/js/theme.js"></script> <script src="/staging/assets/js/dark_mode.js"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/staging/assets/js/distillpub/template.v2.js"></script> <script src="/staging/assets/js/distillpub/transforms.v2.js"></script> <script src="/staging/assets/js/distillpub/overrides.js"></script> <style type="text/css">.caption{font-size:.8em;text-align:center;color:grey}h1{font-size:2.5em;margin:.3em 0 .3em}h2{font-size:2em}h3{font-size:1.5em;margin-top:0}.fake-img{margin-bottom:12px}.fake-img p{font-family:monospace;color:white;text-align:left;margin:12px 0;text-align:center;font-size:16px}</style> </head> <d-front-matter> <script async type="text/json">{
      "title": "How does model size impact catastrophic forgetting in online continual learning?",
      "description": "Yes, model size matters.",
      "published": "November 9, 2023",
      "authors": [
        {
          "author": "Eunhae Lee",
          "authorURL": "https://www.linkedin.com/in/eunhaelee/",
          "affiliations": [
            {
              "name": "MIT",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> <body class="fixed-top-nav"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/staging/">6.S898 Deep Learning Blogs 2023</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/staging/blog/index.html">blog</a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">past iterations</a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item" href="https://iclr-blog-track.github.io/home/">2022</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> </header> <div class="post distill"> <d-title> <h1>How does model size impact catastrophic forgetting in online continual learning?</h1> <p>Yes, model size matters.</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div><a href="#introduction">Introduction</a></div> <div><a href="#related-work">Related Work</a></div> <div><a href="#method">Method</a></div> <div><a href="#experiment">Experiment</a></div> <div><a href="#results">Results</a></div> <div><a href="#discussion">Discussion</a></div> <div><a href="#conclusion">Conclusion</a></div> </nav> </d-contents> <h1 id="introduction">Introduction</h1> <p>One of the biggest unsolved challenges in continual learning is preventing forgetting previously learned information upon acquiring new information. Known as “catastrophic forgetting,” this phenomenon is particularly pertinent in scenarios where AI systems must adapt to new data without losing valuable insights from past experiences. Numerous studies have investigated different approaches to solving this problem in the past years, mostly around proposing innovative strategies to modify the way models are trained and measuring its impact on model performance, such as accuracy and forgetting.</p> <p>Yet, compared to the numerous amount of studies done in establishing new strategies and evaluative approaches in visual continual learning, there is surprisingly little discussion on the impact of model size. It is commonly known that the size of a deep learning model (the number of parameters) is known to play a crucial role in its learning capabilities <d-cite key="hu2021model, Bianco_2018"></d-cite>. Given the limitations in computational resources in most real-world circumstances, it is often not practical or feasible to choose the largest model available. In addition, sometimes smaller models perform just as well as larger models in specific contexts<d-cite key="Bressem_2020"></d-cite>. Given this context, a better understanding of how model size impacts performance in a continual learning setting can provide insights and implications on real-world deployment of continual learning systems.</p> <p>In this blog post, I explore the following research question: <em>How do network depth and width impact model performance in an online continual learning setting?</em> I set forth a hypothesis based on existing literature and conduct a series experiments with models of varying sizes to explore this relationship. This study aims to shed light on whether larger models truly offer an advantage in mitigating catastrophic forgetting, or if the reality is more nuanced.</p> <h1 id="related-work">Related Work</h1> <h3 id="online-continual-learning">Online continual learning</h3> <p>Continual learning (CL), also known as lifelong learning or incremental learning, is an approach that seeks to continually learn from non-iid data streams without forgetting previously acquired knowledge. The challenge in continual learning is generally known as the stability-plasticity dilemma<d-cite key="mermillod2013-dilemma"></d-cite>, and the goal of continual learning is to strike a balance between learning stability and plasticity.</p> <p>While traditional CL models assume new data arrives task by task, each with a stable data distribution, enabling <em>offline</em> training. However, this requires having access to all task data, which can be impractical due to privacy or resource limitations. In this study, I will consider a more realistic setting of Online Continual Learning (OCL), where data arrives in smaller batches and are not accessible after training, requiring models to learn from a single pass over an online data stream. This allows the model to learn data in real-time<d-cite key="soutif-cormerais_comprehensive_2023, cai_online_2021, mai_online_2021"></d-cite>.</p> <p>Online continual learning can involve adapting to new classes (class-incremental) or changing data characteristics (domain-incremental). Specifically, for class-incremental learning, the goal is to continually expand the model’s ability to recognize an increasing number of classes, maintaining its performance on all classes it has seen so far, despite not having continued access to the old class data<d-cite key="soutif-cormerais_comprehensive_2023, ghunaim_real-time_2023"></d-cite>. Moreover, there has been more recent work done in unsupervised continual learning <d-cite key="yu_scale_2023, madaan_representational_2022"></d-cite>. To narrow the scope of the vast CL landscape to focus on learning the impact of model size in CL performance, I will focus on the more common problem of class-incremental learning in supervised image classification in this study.</p> <h3 id="continual-learning-techniques">Continual learning techniques</h3> <p>Popular methods to mitigate catastrophic forgetting in continual learning generally fall into three buckets:<d-cite key="ghunaim_real-time_2023"> :</d-cite></p> <ol> <li><em>regularization-based</em> approaches that modify the classification objective to preserve past representations or foster more insightful representations, such as Elastic Weight Consolidation (EWC)<d-cite key="kirkpatrick2017overcoming"></d-cite> and Learning without Forgetting (LwF)<d-cite key="li_learning_2017"></d-cite>;</li> <li><em>memory-based</em> approaches that replay samples retrieved from a memory buffer along with every incoming mini-batch, including Experience Replay (ER)<d-cite key="chaudhry2019tiny"></d-cite> and Maximally Interfered Retrieval<d-cite key="aljundi2019online"></d-cite>, with variations on how the memory is retrieved and how the model and memory are updated; and</li> <li><em>architectural</em> approaches including parameter-isolation approaches where new parameters are added for new tasks and leaving previous parameters unchanged such as Progressive Neural Networks (PNNs)<d-cite key="rusu2022progressive"></d-cite>.</li> </ol> <p>Moreover, there are many methods that combine two or more of these techniques such as Averaged Gradient Episodic Memory (A-GEM)<d-cite key="chaudhry2019efficient"></d-cite> and Incremental Classifier and Representation Learning (iCaRL)<d-cite key="rebuffi2017icarl"></d-cite>.</p> <p>Among the methods, <strong>Experience Replay (ER)</strong> is a classic replay-based method and widely used for online continual learning. Despite its simplicity, recent studies have shown ER still outperforms many of the newer methods that have come after that, especially for online continual learning <d-cite key="soutif-cormerais_comprehensive_2023, mai_online_2021, ghunaim_real-time_2023"></d-cite>.</p> <h3 id="model-size-and-performance">Model size and performance</h3> <p>It is generally known across literature that deeper models increase performance<d-cite key="hu2021model"></d-cite>. Bianco et al. conducted a survey of key performance-related metrics to compare across various architectures, including accuracy, model complexity, computational complexity, and accuracy density<d-cite key="Bianco_2018"></d-cite>. Relationship between model width and performance is also been discussed<d-cite key="hu2021model"></d-cite>, albeit less frequently.</p> <p>He et al. introduced Residual Networks (ResNets)<d-cite key="he2015deep"></d-cite> which was a major innovation in computer vision by tackling the problem of degradation in deeper networks. ResNets do this by residual blocks to increase the accuracy of deeper models. Residual blocks that contain two ore more layers are stacked together, and “skip connections” are used in between these blocks. The skip connections act as an alternate shortcut for the gradient to pass through, which alleviates the issue of vanishing gradient. They also make it easier for the model to learn identity functions. As a result, ResNet improves the efficiency of deep neural networks with more neural layers while minimizing the percentage of errors. The authors compare models of different depths (composed of 18, 34, 50, 101, 152 layers) and show that accuracy increases with depth of the model.</p> <table> <thead> <tr> <th style="text-align: center"> </th> <th style="text-align: center"><strong>ResNet18</strong></th> <th style="text-align: center"><strong>ResNet34</strong></th> <th style="text-align: center"><strong>ResNet50</strong></th> <th style="text-align: center"><strong>ResNet101</strong></th> <th style="text-align: center"><strong>ResNet152</strong></th> </tr> </thead> <tbody> <tr> <td style="text-align: center"><strong>Number of Layers</strong></td> <td style="text-align: center">18</td> <td style="text-align: center">34</td> <td style="text-align: center">50</td> <td style="text-align: center">101</td> <td style="text-align: center">152</td> </tr> <tr> <td style="text-align: center"><strong>Number of Parameters</strong></td> <td style="text-align: center">~11.7 million</td> <td style="text-align: center">~21.8 million</td> <td style="text-align: center">~25.6 million</td> <td style="text-align: center">~44.5 million</td> <td style="text-align: center">~60 million</td> </tr> <tr> <td style="text-align: center"><strong>Top-1 Accuracy</strong></td> <td style="text-align: center">69.76%</td> <td style="text-align: center">73.31%</td> <td style="text-align: center">76.13%</td> <td style="text-align: center">77.37%</td> <td style="text-align: center">78.31%</td> </tr> <tr> <td style="text-align: center"><strong>Top-5 Accuracy</strong></td> <td style="text-align: center">89.08%</td> <td style="text-align: center">91.42%</td> <td style="text-align: center">92.86%</td> <td style="text-align: center">93.68%</td> <td style="text-align: center">94.05%</td> </tr> <tr> <td style="text-align: center"><strong>FLOPs</strong></td> <td style="text-align: center">1.8 billion</td> <td style="text-align: center">3.6 billion</td> <td style="text-align: center">3.8 billion</td> <td style="text-align: center">7.6 billion</td> <td style="text-align: center">11.3 billion</td> </tr> </tbody> </table> <div class="caption">Table 1: Comparison of ResNet Architectures</div> <p>This leads to the question: do larger models perform better in continual learning? While much of the focus in continual learning research has often been on developing various strategies, methods, and establishing benchmarks, the impact of model scale remains a less explored path.</p> <p>Moreover, recent studies on model scale in slightly different contexts have shown conflicting results. Luo et al.<d-cite key="luo2023empirical"></d-cite> highlights a direct correlation between increasing model size and the severity of catastrophic forgetting in large language models (LLMs). They test models of varying sizes from 1 to 7 billion parameters. Yet, Dyer et al.<d-cite key="dyer2022"></d-cite> show a constrasting perspective in the context of pretrained deep learning models. Their results show that large, pretrained ResNets and Transformers are a lot more resistant to forgetting than randomly-initialized, trained-from-scratch models, and that this tendency increases with the scale of model and the pretraining dataset size.</p> <p>The relative lack of discussion on model size and the conflicting perspectives among existing studies indicate that the answer to the question is far from being definitive. In the next section, I will describe further how I approach this study.</p> <h1 id="method">Method</h1> <h3 id="problem-definition">Problem definition</h3> <p>Online continual learning can be defined as follows<d-cite key="cai_online_2021, ghunaim_real-time_2023"></d-cite>:</p> <p>The objective is to learn a function $f_\theta : \mathcal X \rightarrow \mathcal Y$ with parameters $\theta$ that predicts the label $Y \in \mathcal Y$ of the input $\mathbf X \in \mathcal X$. Over time steps $t \in \lbrace 1, 2, \ldots \infty \rbrace$, a distribution-varying stream $\mathcal S$ reveals data sequentially, which is different from classical supervised learning.</p> <p>At every time step,</p> <ol> <li>$\mathcal S$ reveals a set of data points (images) $\mathbf X_t \sim \pi_t$ from a non-stationary distribution $\pi_t$</li> <li>Learner $f_\theta$ makes predictions $\hat Y_t$ based on current parameters $\theta_t$</li> <li>$\mathcal S$ reveals true labels $Y_t$</li> <li>Compare the predictions with the true labels, compute the training loss $L(Y_t, \hat Y_t)$</li> <li>Learner updates the parameters of the model to $\theta_{t+1}$</li> </ol> <h3 id="task-agnostic-and-boundary-agnostic">Task-agnostic and boundary-agnostic</h3> <p>In the context of class-incremental learning, I will adopt the definitions of task-agnostic and boundary-agnostic from Soutif et al. 2023<d-cite key="soutif-cormerais_comprehensive_2023"></d-cite>. A <em>task-agnostic</em> setting refers to when task labels are not available, which means the model does not know that the samples belong to a certain task. A <em>boundary-agnostic</em> setting is considered, where information on task boundaries are not available. This means that the model does not know when the data distribution changes to a new task.</p> <table> <thead> <tr> <th style="text-align: center"> </th> <th style="text-align: center"><strong>Yes</strong></th> <th style="text-align: center"><strong>No</strong></th> </tr> </thead> <tbody> <tr> <td style="text-align: center"><strong>Task labels</strong></td> <td style="text-align: center">Task-aware</td> <td style="text-align: center">Task-agnotic</td> </tr> <tr> <td style="text-align: center"><strong>Task boundaries</strong></td> <td style="text-align: center">Boundary-aware</td> <td style="text-align: center">Boundary-agnostic</td> </tr> </tbody> </table> <div class="caption">Table 2: Task labels and task boundaries. This project assumes task-agnostic and boundary-agnostic settings.</div> <h3 id="experience-replay-er">Experience Replay (ER)</h3> <p>In a class-incremental learning setting, the nature of the Experience Replay (ER) method aligns well with task-agnostic and boundary-agnostic settings. This is because ER focuses on replaying a subset of past experiences, which helps in maintaining knowledge of previous classes without needing explicit task labels or boundaries. This characteristic of ER allows it to adapt to new classes as they are introduced, while retaining the ability to recognize previously learned classes, making it inherently suitable for task-agnostic and boundary-agnostic continual learning scenarios.</p> <p>Implementation-wise, ER involves randomly initializing an external memory buffer $\mathcal M$, then implementing <code class="language-plaintext highlighter-rouge">before_training_exp</code> and <code class="language-plaintext highlighter-rouge">after_training_exp</code> callbacks to use the dataloader to create mini-batches with samples from both training stream and the memory buffer. Each mini-batch is balanced so that all tasks or experiences are equally represented in terms of stored samples<d-cite key="lomonaco2021avalanche"></d-cite>. As ER is known be well-suited for online continual learning, it will be the go-to method used to compare performances across models of varying sizes.</p> <h3 id="benchmark">Benchmark</h3> <p>For this study, the SplitCIFAR-10<d-cite key="lomonaco2021avalanche"></d-cite> is used as the main benchmark. SplitCIFAR-10 splits the popular CIFAR-10 dataset into 5 tasks with disjoint classes, each task including 2 classes each. Each task has 10,000 3×32×32 images for training and 2000 images for testing. The model is exposed to these tasks or experiences sequentially, which simulates a real-world scenario where a learning system is exposed to new categories of data over time. This is suitable for class-incremental learning scenarios. This benchmark is used for both testing online and offline continual learning in this study.</p> <h3 id="metrics">Metrics</h3> <p>Key metrics established in earlier work in online continual learning are used to evaluate the performance of each model.</p> <p><strong>Average Anytime Accuracy (AAA)</strong> as defined in <d-cite key="caccia_new_2022"></d-cite></p> <p>The concept of average anytime accuracy serves as an indicator of a model’s overall performance throughout its learning phase, extending the idea of average incremental accuracy to include continuous assessment scenarios. This metric assesses the effectiveness of the model across all stages of training, rather than at a single endpoint, offering a more comprehensive view of its learning trajectory.</p> \[\text{AAA} = \frac{1}{T} \sum_{t=1}^{T} (\text{AA})_t\] <p><strong>Average Cumulative Forgetting (ACF)</strong> as defined in <d-cite key="soutif-cormerais_comprehensive_2023, soutifcormerais2021importance"></d-cite></p> <p>This equation represents the calculation of the <strong>Cumulative Accuracy</strong> ($b_k^t$) for task $k$ after the model has been trained up to task $t$. It computes the mean accuracy over the evaluation set $E^k_\Sigma$, which contains all instances $x$ and their true labels $y$ up to task $k$. The model’s prediction for each instance is given by $\underset{c \in C^k_\Sigma}{\text{arg max }} f^t(x)_c$, which selects the class $c$ with the highest predicted logit $f^t(x)_c$. The indicator function $1_y(\hat{y})$ outputs 1 if the prediction matches the true label, and 0 otherwise. The sum of these outputs is then averaged over the size of the evaluation set to compute the cumulative accuracy.</p> \[b_k^t = \frac{1}{|E^k_\Sigma|} \sum_{(x,y) \in E^k_\Sigma} 1_y(\underset{c \in C^k_\Sigma}{\text{arg max }} f^t(x)_c)\] <p>From Cumulative Accuracy, we can calculate the <strong>Average Cumulative Forgetting</strong> ($F_{\Sigma}^t$) by setting the cumulative forgetting about a previous cumulative task $k$, then averaging over all tasks learned so far:</p> \[F_{\Sigma}^t = \frac{1}{t-1} \sum_{k=1}^{t-1} \max_{i=1,...,t} \left( b_k^i - b_k^t \right)\] <p><strong>Average Accuracy (AA) and Average Forgetting (AF)</strong> as defined in <d-cite key="mai_online_2021"></d-cite></p> <p>$a_{i,j}$ is the accuracy evaluated on the test set of task $j$ after training the network from task 1 to $i$, while $i$ is the current task being trained. Average Accuracy (AA) is computed by averaging this over the number of tasks.</p> \[\text{Average Accuracy} (AA_i) = \frac{1}{i} \sum_{j=1}^{i} a_{i,j}\] <p>Average Forgetting measures how much a model’s performance on a previous task (task $j$) decreases after it has learned a new task (task $i$). It is calculated by comparing the highest accuracy the model $\max_{l \in {1, \ldots, k-1}} (a_{l, j})$ had on task $j$ before it learned task $k$, with the accuracy $a_{k, j}$ on task $j$ after learning task $k$.</p> \[\text{Average Forgetting}(F_i) = \frac{1}{i - 1} \sum_{j=1}^{i-1} f_{i,j}\] \[f_{k,j} = \max_{l \in \{1,...,k-1\}} (a_{l,j}) - a_{k,j}, \quad \forall j &lt; k\] <p>In the context of class-incremental learning, the concept of classical forgetting may not provide meaningful insight due to its tendency to increase as the complexity of the task grows (considering more classes within the classification problem). Therefore, <d-cite key="soutif-cormerais_comprehensive_2023"></d-cite>recommendeds avoiding relying on classical forgetting as a metric in settings of class-incremental learning, both online and offline settings. Thus, Average Anytime Accuracy (AAA) and Average Cumulative Forgetting (ACF) are used throughout this experiment, although AA and AF are computed as part of the process.</p> <h3 id="model-selection">Model selection</h3> <p>To compare learning performance across varying model depths, I chose to use the popular ResNet architectures, particularly ResNet18, ResNet34, and ResNet50. As mentioned earlier in this blog, ResNets were designed to increase the performance of deeper neural networks, and their performance metrics are well known. While using custom models for more variability in sizes was a consideration, existing popular architectures were chosen for better reproducibility.</p> <p>Moreover, while there are newer versions (i.e. ResNeXt<d-cite key="xie2017aggregated"></d-cite>) that have shown to perform better without a huge increase in computational complexity<d-cite key="Bianco_2018"></d-cite>, for this study the original smaller models were chosen to avoid introducing unnecessary variables. ResNet18 and ResNet34 have the basic residual network structure, and ResNet50, ResNet101, and ResNet152 use slightly modified building blocks that have 3 layers instead of 2. This ”bottleneck design” was made to reduce training time. The specifics of the design of these models are detailed in the table from the original paper by He et al.<d-cite key="he2015deep"></d-cite>.</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/staging/assets/img/2023-11-09-eunhae-project/resnets_comparison-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/staging/assets/img/2023-11-09-eunhae-project/resnets_comparison-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/staging/assets/img/2023-11-09-eunhae-project/resnets_comparison-1400.webp"/> <img src="/staging/assets/img/2023-11-09-eunhae-project/resnets_comparison.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture><figcaption class="caption">ResNet architecture. Table from He et al. (2015)</figcaption> </figure> <p>Moreover, in order to observe the effect of model width on performance, I also test a slim version of ResNet18 that has been used in previous works<d-cite key="lopez-paz_gradient_2017"></d-cite>. The slim version uses fewer filters per layer, reducing the model width and computational load while keeping the original depth.</p> <h3 id="saliency-maps">Saliency maps</h3> <p>I use saliency maps to visualize “attention” of the networks. Saliency maps are known to be useful for understanding which parts of the input image are most influential for the model’s predictions. By visualizing the specific areas of an image that a CNN considers important for classification, saliency maps provide insights into the internal representation and decision-making process of the network<d-cite key="simonyan2014deep"></d-cite>.</p> <h1 id="experiment">Experiment</h1> <h3 id="the-setup">The setup</h3> <ul> <li>Each model was trained from scratch using the Split-CIFAR10 benchmark with 2 classes per task, for 3 epoches with a mini-batch size of 64.</li> <li>SGD optimizer with a 0.9 momentum and 1e-5 weight decay was used. The initial learning rate is set to 0.01 and the scheduler reduces it by a factor of 0.1 every 30 epochs, as done in <d-cite key="lin_clear_2022"></d-cite>.</li> <li>Cross entropy loss is used as the criterion, as is common for image classification in continual learning.</li> <li>Basic data augmentation is done on the training data to enhance model robustness and generalization by artificially expanding the dataset with varied, modified versions of the original images.</li> <li>Each model is trained offline as well to serve as baselines.</li> <li>Memory size of 500 is used to implement Experience Replay. This represents 1% of the training dataset.</li> </ul> <h3 id="implementation">Implementation</h3> <p>The continual learning benchmark was implemented using the Avalanche framework<d-cite key="lomonaco2021avalanche"></d-cite>, an open source continual learning library, as well as the code for online continual learning by Soutif et al.<d-cite key="soutif-cormerais_comprehensive_2023"></d-cite>. The experiments were run on Google Colab using NVIDIA Tesla T4 GPU.</p> <table> <thead> <tr> <th style="text-align: center"> </th> <th style="text-align: center"><strong>Experiment 1</strong></th> <th style="text-align: center"><strong>Experiment 2</strong></th> <th style="text-align: center"><strong>Experiment 3</strong></th> <th style="text-align: center"><strong>Experiment 4</strong></th> <th style="text-align: center"><strong>Experiment 5</strong></th> <th style="text-align: center"><strong>Experiment 6</strong></th> <th style="text-align: center"><strong>Experiment 7</strong></th> </tr> </thead> <tbody> <tr> <td style="text-align: center"><strong>Model</strong></td> <td style="text-align: center">ResNet18</td> <td style="text-align: center">ResNet34</td> <td style="text-align: center">ResNet50</td> <td style="text-align: center">SlimResNet18</td> <td style="text-align: center">ResNet18</td> <td style="text-align: center">ResNet34</td> <td style="text-align: center">ResNet50</td> </tr> <tr> <td style="text-align: center"><strong>Strategy</strong></td> <td style="text-align: center">Experience Replay</td> <td style="text-align: center">Experience Replay</td> <td style="text-align: center">Experience Replay</td> <td style="text-align: center">Experience Replay</td> <td style="text-align: center">Experience Replay</td> <td style="text-align: center">Experience Replay</td> <td style="text-align: center">Experience Replay</td> </tr> <tr> <td style="text-align: center"><strong>Benchmark</strong></td> <td style="text-align: center">SplitCIFAR10</td> <td style="text-align: center">SplitCIFAR10</td> <td style="text-align: center">SplitCIFAR10</td> <td style="text-align: center">SplitCIFAR10</td> <td style="text-align: center">SplitCIFAR10</td> <td style="text-align: center">SplitCIFAR10</td> <td style="text-align: center">SplitCIFAR10</td> </tr> <tr> <td style="text-align: center"><strong>Training</strong></td> <td style="text-align: center">Online</td> <td style="text-align: center">Online</td> <td style="text-align: center">Online</td> <td style="text-align: center">Online</td> <td style="text-align: center">Offline</td> <td style="text-align: center">Offline</td> <td style="text-align: center">Offline</td> </tr> <tr> <td style="text-align: center"><strong>GPU</strong></td> <td style="text-align: center">V100</td> <td style="text-align: center">T4</td> <td style="text-align: center">A100</td> <td style="text-align: center">T4</td> <td style="text-align: center">T4</td> <td style="text-align: center">T4</td> <td style="text-align: center">T4</td> </tr> <tr> <td style="text-align: center"><strong>Training time (estimate)</strong></td> <td style="text-align: center">3h</td> <td style="text-align: center">4.5h</td> <td style="text-align: center">5h</td> <td style="text-align: center">1h</td> <td style="text-align: center">&lt;5m</td> <td style="text-align: center">&lt;5m</td> <td style="text-align: center">&lt;5m</td> </tr> </tbody> </table> <div class="caption">Table 3: Details of experiments conducted in this study</div> <h1 id="results">Results</h1> <p>Average Anytime Accuracy (AAA) decreases with model size (Chart 1), with a sharper drop from ResNet34 to ResNet50. The decrease in AAA is more significant in online learning than offline learning.</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/staging/assets/img/2023-11-09-eunhae-project/AAA_on_off-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/staging/assets/img/2023-11-09-eunhae-project/AAA_on_off-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/staging/assets/img/2023-11-09-eunhae-project/AAA_on_off-1400.webp"/> <img src="/staging/assets/img/2023-11-09-eunhae-project/AAA_on_off.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture><figcaption class="caption">Chart 1: Average Anytime Accuracy (AAA) of different sized ResNets in online and offline continual learning</figcaption> </figure> <p>When looking at average accuracy for validation stream for online CL setting (Chart 2), we see that the rate to which accuracy increases with each task degrade with larger models. Slim-ResNet18 shows the highest accuracy and growth trend. This could indicate that larger models are worse at generalizing to a class-incremental learning scenario.</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/staging/assets/img/2023-11-09-eunhae-project/stream_acc1-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/staging/assets/img/2023-11-09-eunhae-project/stream_acc1-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/staging/assets/img/2023-11-09-eunhae-project/stream_acc1-1400.webp"/> <img src="/staging/assets/img/2023-11-09-eunhae-project/stream_acc1.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture><figcaption class="caption">Chart 2: Validation stream accuracy (Online CL)</figcaption> </figure> <table> <thead> <tr> <th style="text-align: center"> </th> <th style="text-align: center"><strong>Average Anytime Acc (AAA)</strong></th> <th style="text-align: center"><strong>Final Average Acc</strong></th> </tr> </thead> <tbody> <tr> <td style="text-align: center"><strong>Slim ResNet18</strong></td> <td style="text-align: center">0.664463</td> <td style="text-align: center">0.5364</td> </tr> <tr> <td style="text-align: center"><strong>ResNet18</strong></td> <td style="text-align: center">0.610965</td> <td style="text-align: center">0.3712</td> </tr> <tr> <td style="text-align: center"><strong>ResNet34</strong></td> <td style="text-align: center">0.576129</td> <td style="text-align: center">0.3568</td> </tr> <tr> <td style="text-align: center"><strong>ResNet50</strong></td> <td style="text-align: center">0.459375</td> <td style="text-align: center">0.3036</td> </tr> </tbody> </table> <div class="caption">Table 4: Accuracy metrics across differently sized models (Online CL) </div> <p>Now we turn to forgetting.</p> <p>Looking at Average Cumulative Forgetting (ACF), we see that for online CL setting, ResNet34 performs the best (with a slight overlap at the end with ResNet18), and ResNet50 shows the mosts forgetting. An noticeable observation in both ACF and AF is that ResNet50 performed better initially but forgetting started to increase after a few tasks.</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/staging/assets/img/2023-11-09-eunhae-project/forgetting_online-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/staging/assets/img/2023-11-09-eunhae-project/forgetting_online-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/staging/assets/img/2023-11-09-eunhae-project/forgetting_online-1400.webp"/> <img src="/staging/assets/img/2023-11-09-eunhae-project/forgetting_online.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture><figcaption class="caption">Chart 3: forgetting curves, Online CL (Solid: Average Forgetting (AF); Dotted: Average Cumulative Forgetting (ACF))</figcaption> </figure> <p>However, results look different for offline CL setting. ResNet50 has the lowest Average Cumulative Forgetting (ACF) (although with a slight increase in the middle), followed by ResNet18, and finally ResNet34. This differences in forgetting between online and offline CL setting is aligned with the accuracy metrics earlier, where the performance of ResNet50 decreases more starkly in the online CL setting.</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/staging/assets/img/2023-11-09-eunhae-project/forgetting_offline-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/staging/assets/img/2023-11-09-eunhae-project/forgetting_offline-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/staging/assets/img/2023-11-09-eunhae-project/forgetting_offline-1400.webp"/> <img src="/staging/assets/img/2023-11-09-eunhae-project/forgetting_offline.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture><figcaption class="caption">Chart 4: Forgetting curves, Offline CL (Solid: Average Forgetting (AF); Dotted: Average Cumulative Forgetting (ACF))</figcaption> </figure> <p>Visual inspection of the saliency maps revealed some interesting observations. When it comes to the ability to highlight intuitive areas of interest in the images, there seemed to be a noticeable improvement from ResNet18 to ResNet34, but this was not necessarily the case from ResNet34 to ResNet50. This phenomenon was more salient in the online CL setting.</p> <p><strong>Online</strong></p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/staging/assets/img/2023-11-09-eunhae-project/saliency_online-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/staging/assets/img/2023-11-09-eunhae-project/saliency_online-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/staging/assets/img/2023-11-09-eunhae-project/saliency_online-1400.webp"/> <img src="/staging/assets/img/2023-11-09-eunhae-project/saliency_online.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture><figcaption class="caption">Image: Saliency map visualizations for Online CL</figcaption> </figure> <p><strong>Offline</strong></p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/staging/assets/img/2023-11-09-eunhae-project/saliency_offline-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/staging/assets/img/2023-11-09-eunhae-project/saliency_offline-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/staging/assets/img/2023-11-09-eunhae-project/saliency_offline-1400.webp"/> <img src="/staging/assets/img/2023-11-09-eunhae-project/saliency_offline.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture><figcaption class="caption">Image: Saliency map visualization for Offline CL</figcaption> </figure> <p>Interestingly, Slim-ResNet18 seems to be doing better than most of them, certainly better than its plain counterpart ResNet18. A further exploration of model width on performance and representation quality would be an interesting avenue of research.</p> <p><strong>Slim-ResNet18</strong></p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/staging/assets/img/2023-11-09-eunhae-project/saliencymap_exp4-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/staging/assets/img/2023-11-09-eunhae-project/saliencymap_exp4-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/staging/assets/img/2023-11-09-eunhae-project/saliencymap_exp4-1400.webp"/> <img src="/staging/assets/img/2023-11-09-eunhae-project/saliencymap_exp4.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture><figcaption class="caption">Image: Saliency map visualization (Slim ResNet18)</figcaption> </figure> <h1 id="discussion">Discussion</h1> <p>In this study, I compared key accuracy and forgetting metrics in online continual learning across ResNets of different depths and width, as well as brief qualitative inspection of the models’ internal representation. These results show that larger models do not necessary lead to better continual learning performance. We saw that Average Anytime Accuracy (AAA) and stream accuracy dropped progressively with model size, hinting that larger models struggle to generalize to newly trained tasks, especially in an online CL setting. Forgetting curves showed similar trends but with more nuance; larger models perform well at first but suffer from increased forgetting with more incoming tasks. Interestingly, the problem was not as pronounced in the offline CL setting, which highlights the challenges of training models in a more realistic, online continual learning context.</p> <p>Why do larger models perform worse at continual learning? One of the reasons is that larger models tend to have more parameters, which might make it harder to maintain stability in the learned features as new data is introduced. This makes them more prone to overfitting and forgetting previously learned information, reducing their ability to generalize.</p> <p>Building on this work, future research could investigate the impact of model size on CL performance by exploring the following questions:</p> <ul> <li>Do pre-trained larger models (vs trained-from-scratch models) generalize better in continual learning settings?</li> <li>Do longer training improve relatively performance of larger models in CL setting?</li> <li>Can different CL strategies (other than Experience Replay) mitigate the degradation of performance in larger models?</li> <li>Do slimmer versions of existing models always perform better?</li> <li>How might different hyperparameters (i.e. learning rate) impact CL performance of larger models?</li> </ul> <h1 id="conclusion">Conclusion</h1> <p>To conclude, this study has empirically explored the role of model size on performance in the context of online continual learning. Specifically, it has shown that model size matters when it comes to continual learning and forgetting, albeit in nuanced ways. These findings contribute to the ongoing discussions on the role of the scale of deep learning models on performance and have implications for future area of research.</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> </div> <d-bibliography src="/staging/assets/bibliography/2023-11-09-eunhae-project.bib"></d-bibliography> <script src="https://utteranc.es/client.js" repo="iclr-blogposts/2023" issue-term="pathname" theme="github-light" crossorigin="anonymous" async> </script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> </body> </html>